using Bloodlust.Deobfuscation;
using Bloodlust.Menu;
using Bloodlust.Menu.Elements;
using Bloodlust.Utils;
using GameModes.GameplayMode.Interactables.InventoryItems;
using HarmonyLib;
using System;

namespace Bloodlust.Features.MenuCategories;

[HarmonyPatch]
public static class ItemExploits
{
    private static BloodlustMenu.Category _category;
    private static ToggleElement _infiniteRifleAmmo;
    private static ToggleElement _infiniteSlingshotNuts;

    public static void Initialize()
    {
        _infiniteRifleAmmo = new ToggleElement("Infinite Rifle Ammo");
        _infiniteSlingshotNuts = new ToggleElement("Infinite Slingshot Nuts");

        _category = BloodlustMenu.Category.Create("Item Exploits", new()
        {
            _infiniteRifleAmmo,
            _infiniteSlingshotNuts
        });

        GameEvents.OnGameModeChanged.Subscribe(OnGameModeChanged);

        HarmonyUtils.PatchObfuscated(typeof(RifleInventoryItem), RifleInventoryItemUtils.ShootRifleMethod, postfix: new(new Action<RifleInventoryItem>(AfterRifleShootPatch).Method));
        HarmonyUtils.PatchObfuscated(typeof(RifleInventoryItem), RifleInventoryItemUtils.PickUpRifleMethod, new(new Action<RifleInventoryItem>(OnRiflePickUpPatch).Method));
        HarmonyUtils.PatchObfuscated(typeof(SlingshotManager), SlingshotUtils.HasEnoughResourcesMethod, postfix: new(new HasEnoughResourcesPatchDel(HasEnoughResourcesPatch).Method));
    }

    private static void HasEnoughResourcesPatch(ref bool __result)
    {
        if (_infiniteSlingshotNuts.On)
            __result = true;
    }

    private static void OnRiflePickUpPatch(RifleInventoryItem __instance)
    {
        if (!_infiniteRifleAmmo.On)
            return;

        __instance.Reload();
    }

    private static void AfterRifleShootPatch(RifleInventoryItem __instance)
    {
        if (!_infiniteRifleAmmo.On)
            return;

        __instance.Reload();
    }

    private static void OnGameModeChanged(GameMode gameMode)
    {
        _category.Enabled = gameMode == GameMode.GAMEPLAY;
    }

    delegate void HasEnoughResourcesPatchDel(ref bool __result);
}
